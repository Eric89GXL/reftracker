import sys
import gc
import weakref
import types
import re
try:
    import numpy as np
    HAVE_NUMPY = True
except ImportError:
    HAVE_NUMPY = False

__all__ = ['ObjTracker']


def typeStr(obj):
    """Create a more useful type string by making <instance> types report their class."""
    typ = type(obj)
    if typ == getattr(types, 'InstanceType', None):
        return "<instance of %s>" % obj.__class__.__name__
    else:
        return str(typ)

def objString(obj):
    """Return a short but descriptive string for any object"""
    try:
        if isinstance(obj, (int, float)):
            return str(obj)
        elif isinstance(obj, dict):
            if len(obj) > 5:
                return "<dict {%s,...}>" % (",".join(list(map(str, obj.keys()))[:5]))
            else:
                return "<dict {%s}>" % (",".join(list(map(str, obj.keys()))))
        elif isinstance(obj, str):
            if len(obj) > 50:
                return '"%s..."' % obj[:50]
            else:
                return obj[:]
        elif HAVE_NUMPY and isinstance(obj, np.ndarray):
            return "<ndarray %s %s>" % (str(obj.dtype), str(obj.shape))
        elif hasattr(obj, '__len__'):
            if len(obj) > 5:
                return "<%s [%s,...]>" % (type(obj).__name__, ",".join([type(o).__name__ for o in obj[:5]]))
            else:
                return "<%s [%s]>" % (type(obj).__name__, ",".join([type(o).__name__ for o in obj]))
        elif isinstance(obj, types.ModuleType):
            return obj.__name__
        else:
            return "<%s %s>" % (type(obj).__name__, obj.__class__.__name__)
    except Exception:
        raise
        return str(type(obj))

    
def refPathString(chain):
    """Given a list of adjacent objects in a reference path, print the 'natural' path
    names (ie, attribute names, keys, and indexes) that follow from one object to the next ."""
    s = objString(chain[0])
    i = 0
    while i < len(chain)-1:
        #print " -> ", i
        i += 1
        o1 = chain[i-1]
        o2 = chain[i]
        cont = False
        if isinstance(o1, list) or isinstance(o1, tuple):
            if any([o2 is x for x in o1]):
                s += "[%d]" % o1.index(o2)
                continue
        #print "  not list"
        if isinstance(o2, dict) and hasattr(o1, '__dict__') and o2 == o1.__dict__:
            i += 1
            if i >= len(chain):
                s += ".__dict__"
                continue
            o3 = chain[i]
            for k in o2:
                if o2[k] is o3:
                    s += '.%s' % k
                    cont = True
                    continue
        #print "  not __dict__"
        if isinstance(o1, dict):
            try:
                if o2 in o1:
                    s += "[key:%s]" % objString(o2)
                    continue
            except TypeError:
                pass
            for k in o1:
                if o1[k] is o2:
                    s += "[%s]" % objString(k)
                    cont = True
                    continue
        #print "  not dict"
        #for k in dir(o1):  ## Not safe to request attributes like this.
            #if getattr(o1, k) is o2:
                #s += ".%s" % k
                #cont = True
                #continue
        #print "  not attr"
        if cont:
            continue
        s += " ? "
        sys.stdout.flush()
    return s


def describeObj(obj, depth=4, path=None, ignore=None):
    """
    Trace all reference paths backward, printing a list of different ways this object can be accessed.
    Attempts to answer the question "who has a reference to this object"
    """
    if path is None:
        path = [obj]
    if ignore is None:
        ignore = {}   ## holds IDs of objects used within the function.
    ignore[id(sys._getframe())] = None
    ignore[id(path)] = None
    gc.collect()
    refs = gc.get_referrers(obj)
    ignore[id(refs)] = None
    printed=False
    for ref in refs:
        if id(ref) in ignore:
            continue
        if id(ref) in list(map(id, path)):
            print("Cyclic reference: " + refPathString([ref]+path))
            printed = True
            continue
        newPath = [ref]+path
        if isinstance(ref, types.ModuleType) or len(newPath) >= depth:
            refStr = refPathString(newPath)
            if '[_]' not in refStr:           ## ignore '_' references generated by the interactive shell
                print(refStr)
            printed = True
        else:
            describeObj(ref, depth, newPath, ignore)
            printed = True
    if not printed:
        print("Dead end: " + refPathString(path))
        

def objectSize(obj, ignore=None, verbose=False, depth=0, recursive=False):
    """Guess how much memory an object is using"""
    ignoreTypes = ['MethodType', 'UnboundMethodType', 'BuiltinMethodType', 'FunctionType', 'BuiltinFunctionType']
    ignoreTypes = [getattr(types, key) for key in ignoreTypes if hasattr(types, key)]
    ignoreRegex = re.compile('(method-wrapper|Flag|ItemChange|Option|Mode)')
    
    
    if ignore is None:
        ignore = {}
        
    indent = '  '*depth
    
    try:
        hash(obj)
        hsh = obj
    except:
        hsh = "%s:%d" % (str(type(obj)), id(obj))
        
    if hsh in ignore:
        return 0
    ignore[hsh] = 1
    
    try:
        size = sys.getsizeof(obj)
    except TypeError:
        size = 0
        
    if isinstance(obj, np.ndarray):
        try:
            size += len(obj.data)
        except:
            pass
            
        
    if recursive:
        if type(obj) in [list, tuple]:
            if verbose:
                print(indent+"list:")
            for o in obj:
                s = objectSize(o, ignore=ignore, verbose=verbose, depth=depth+1)
                if verbose:
                    print(indent+'  +', s)
                size += s
        elif isinstance(obj, dict):
            if verbose:
                print(indent+"list:")
            for k in obj:
                s = objectSize(obj[k], ignore=ignore, verbose=verbose, depth=depth+1)
                if verbose:
                    print(indent+'  +', k, s)
                size += s
        #elif isinstance(obj, QtCore.QObject):
            #try:
                #childs = obj.children()
                #if verbose:
                    #print indent+"Qt children:"
                #for ch in childs:
                    #s = objectSize(obj, ignore=ignore, verbose=verbose, depth=depth+1)
                    #size += s
                    #if verbose:
                        #print indent + '  +', ch.objectName(), s
                    
            #except:
                #pass
    #if isinstance(obj, types.InstanceType):
        gc.collect()
        if verbose:
            print(indent+'attrs:')
        for k in dir(obj):
            if k in ['__dict__']:
                continue
            o = getattr(obj, k)
            if type(o) in ignoreTypes:
                continue
            strtyp = str(type(o))
            if ignoreRegex.search(strtyp):
                continue
            #if isinstance(o, types.ObjectType) and strtyp == "<type 'method-wrapper'>":
                #continue
            
            #if verbose:
                #print indent, k, '?'
            refs = [r for r in gc.get_referrers(o) if type(r) != types.FrameType]
            if len(refs) == 1:
                s = objectSize(o, ignore=ignore, verbose=verbose, depth=depth+1)
                size += s
                if verbose:
                    print(indent + "  +", k, s)
            #else:
                #if verbose:
                    #print indent + '  -', k, len(refs)
    return size


#### Code for listing (nearly) all objects in the known universe
#### http://utcc.utoronto.ca/~cks/space/blog/python/GetAllObjects
# Recursively expand slist's objects
# into olist, using seen to track
# already processed objects.
def _getr(slist, olist, first=True):
    i = 0 
    for e in slist:
        
        oid = id(e)
        typ = type(e)
        if oid in olist or typ is int:    ## or e in olist:     ## since we're excluding all ints, there is no longer a need to check for olist keys
            continue
        olist[oid] = e
        if first and (i%1000) == 0:
            gc.collect()
        tl = gc.get_referents(e)
        if tl:
            _getr(tl, olist, first=False)
        i += 1


def get_all_objects():
    """Return a list of all live Python objects (excluding int and long), not including the list itself."""
    gc.collect()
    gcl = gc.get_objects()
    olist = {}
    _getr(gcl, olist)
    
    del olist[id(olist)]
    del olist[id(gcl)]
    del olist[id(sys._getframe())]
    return olist


def lookup(oid, objects=None):
    """Return an object given its ID, if it exists."""
    if objects is None:
        objects = get_all_objects()
    return objects[oid]
        

class ObjTracker(object):
    """
    Tracks all objects under the sun, reporting the changes between snapshots: what objects are created, deleted, and persistent.
    This class is very useful for tracking memory leaks. The class goes to great (but not heroic) lengths to avoid tracking 
    its own internal objects.
    
    Example::
    
        ot = ObjTracker()   # takes snapshot of currently existing objects
           ... do stuff ...
        ot.diff()           # prints lists of objects created and deleted since ot was initialized
           ... do stuff ...
        ot.diff()           # prints lists of objects created and deleted since last call to ot.diff()
                            # also prints list of items that were created since initialization AND have not been deleted yet
                            #   (if done correctly, this list can tell you about objects that were leaked)
           
        arrays = ot.findPersistent('ndarray')  ## returns all objects matching 'ndarray' (string match, not instance checking)
                                               ## that were considered persistent when the last diff() was run
                                               
        arrays.describe[0]    ## See if we can determine who has references to this array
    """
    
    
    allObjs = {} ## keep track of all objects created and stored within class instances
    allObjs[id(allObjs)] = None
    
    def __init__(self):
        self.startRefs = {}        ## list of objects that exist when the tracker is initialized {oid: weakref}
                                   ##   (If it is not possible to weakref the object, then the value is None)
        self.startCount = {}       
        self.newRefs = {}          ## list of objects that have been created since initialization
        self.persistentRefs = {}   ## list of objects considered 'persistent' when the last diff() was called
        self.objTypes = {}
            
        ObjTracker.allObjs[id(self)] = None
        self.objs = [self.__dict__, self.startRefs, self.startCount, self.newRefs, self.persistentRefs, self.objTypes]
        self.objs.append(self.objs)
        for v in self.objs:
            ObjTracker.allObjs[id(v)] = None
            
        self.start()

    def findNew(self, regex, weak=True):
        """Return all objects matching regex that were considered 'new' when 
        the last diff() was run.
        
        Return value is a GarbageWatcher (or a list if weak==False) sorted with 
        the largest items first.
        """
        return self.findTypes(self.newRefs, regex, weak=weak)
    
    def findPersistent(self, regex, weak=True):
        """Return all objects matching regex that were considered 'persistent' 
        when the last diff() was run.
        
        Return value is a GarbageWatcher (or a list if weak==False) sorted with 
        the largest items first.
        """
        return self.findTypes(self.persistentRefs, regex, weak=weak)
        
    def start(self):
        """
        Remember the current set of objects as the comparison for all future calls to diff()
        Called automatically on init, but can be called manually as well.
        """
        refs, count, objs = self.collect()
        for r in self.startRefs:
            self.forgetRef(self.startRefs[r])
        self.startRefs.clear()
        self.startRefs.update(refs)
        for r in refs:
            self.rememberRef(r)
        self.startCount.clear()
        self.startCount.update(count)

    def diff(self, **kargs):
        """
        Compute all differences between the current object set and the reference set.
        Print a set of reports for created, deleted, and persistent objects
        """
        refs, count, objs = self.collect()   ## refs contains the list of ALL objects
        
        ## Which refs have disappeared since call to start()  (these are only displayed once, then forgotten.)
        delRefs = {}
        for i in list(self.startRefs.keys()):
            if i not in refs:
                delRefs[i] = self.startRefs[i]
                del self.startRefs[i]
                self.forgetRef(delRefs[i])
        for i in list(self.newRefs.keys()):
            if i not in refs:
                delRefs[i] = self.newRefs[i]
                del self.newRefs[i]
                self.forgetRef(delRefs[i])
        #print "deleted:", len(delRefs)
                
        ## Which refs have appeared since call to start() or diff()
        persistentRefs = {}      ## created since start(), but before last diff()
        createRefs = {}          ## created since last diff()
        for o in refs:
            if o not in self.startRefs:       
                if o not in self.newRefs:     
                    createRefs[o] = refs[o]          ## object has been created since last diff()
                else:
                    persistentRefs[o] = refs[o]      ## object has been created since start(), but before last diff() (persistent)
        #print "new:", len(newRefs)
                
        ## self.newRefs holds the entire set of objects created since start()
        for r in self.newRefs:
            self.forgetRef(self.newRefs[r])
        self.newRefs.clear()
        self.newRefs.update(persistentRefs)
        self.newRefs.update(createRefs)
        for r in self.newRefs:
            self.rememberRef(self.newRefs[r])
        #print "created:", len(createRefs)
        
        ## self.persistentRefs holds all objects considered persistent.
        self.persistentRefs.clear()
        self.persistentRefs.update(persistentRefs)
        
                
        print("----------- Count changes since start: ----------")
        c1 = count.copy()
        for k in self.startCount:
            c1[k] = c1.get(k, 0) - self.startCount[k]
        typs = list(c1.keys())
        #typs.sort(lambda a,b: cmp(c1[a], c1[b]))
        typs.sort(key=lambda a: c1[a])
        for t in typs:
            if c1[t] == 0:
                continue
            num = "%d" % c1[t]
            print("  " + num + " "*(10-len(num)) + str(t))
            
        print("-----------  %d Deleted since last diff: ------------" % len(delRefs))
        self.report(delRefs, objs, **kargs)
        print("-----------  %d Created since last diff: ------------" % len(createRefs))
        self.report(createRefs, objs, **kargs)
        print("-----------  %d Created since start (persistent): ------------" % len(persistentRefs))
        self.report(persistentRefs, objs, **kargs)
        
    def __del__(self):
        self.startRefs.clear()
        self.startCount.clear()
        self.newRefs.clear()
        self.persistentRefs.clear()
        
        del ObjTracker.allObjs[id(self)]
        for v in self.objs:
            del ObjTracker.allObjs[id(v)]
            
    @classmethod
    def isObjVar(cls, o):
        return type(o) is cls or id(o) in cls.allObjs
            
    def collect(self):
        print("Collecting list of all objects...")
        gc.collect()
        objs = get_all_objects()
        frame = sys._getframe()
        del objs[id(frame)]  ## ignore the current frame 
        del objs[id(frame.f_code)]
        
        ignoreTypes = [int]
        refs = {}
        count = {}
        for k in objs:
            o = objs[k]
            typ = type(o)
            oid = id(o)
            if ObjTracker.isObjVar(o) or typ in ignoreTypes:
                continue
            
            try:
                ref = weakref.ref(obj)
            except:
                ref = None
            refs[oid] = ref
            typ = type(o)
            typStr = typeStr(o)
            self.objTypes[oid] = typStr
            ObjTracker.allObjs[id(typStr)] = None
            count[typ] = count.get(typ, 0) + 1
            
        print("All objects: %d   Tracked objects: %d" % (len(objs), len(refs)))
        return refs, count, objs
        
    def forgetRef(self, ref):
        if ref is not None:
            del ObjTracker.allObjs[id(ref)]
        
    def rememberRef(self, ref):
        ## Record the address of the weakref object so it is not included in future object counts.
        if ref is not None:
            ObjTracker.allObjs[id(ref)] = None
            
    def lookup(self, oid, ref, objs=None):
        if ref is None or ref() is None:
            try:
                obj = lookup(oid, objects=objs)
            except:
                obj = None
        else:
            obj = ref()
        return obj
                    
    def report(self, refs, allobjs=None, showIDs=False):
        if allobjs is None:
            allobjs = get_all_objects()
        
        count = {}
        rev = {}
        for oid in refs:
            obj = self.lookup(oid, refs[oid], allobjs)
            if obj is None:
                typ = "[del] " + self.objTypes[oid]
            else:
                typ = typeStr(obj)
            if typ not in rev:
                rev[typ] = []
            rev[typ].append(oid)
            c = count.get(typ, [0,0])
            count[typ] =  [c[0]+1, c[1]+objectSize(obj)]
        typs = list(count.keys())
        #typs.sort(lambda a,b: cmp(count[a][1], count[b][1]))
        typs.sort(key=lambda a: count[a][1])
        
        for t in typs:
            line = "  %d\t%d\t%s" % (count[t][0], count[t][1], t)
            if showIDs:
                line += "\t"+",".join(map(str,rev[t]))
            print(line)
        
    def findTypes(self, refs, regex, weak=True):
        allObjs = get_all_objects()
        ids = {}
        objs = []
        r = re.compile(regex)
        for k in refs:
            if r.search(self.objTypes[k]):
                o = self.lookup(k, refs[k], allObjs)
                objs.append((objectSize(o), o))
        objs.sort(key=lambda a: a[0], reverse=True)
        if weak:
            gw = GarbageWatcher()
            for i,o in enumerate(objs):
                gw[i] = o[1]
            return gw
        else:
            return objs


class GarbageWatcher(object):
    """
    Convenient dictionary for holding weak references to objects.
    Mainly used to check whether the objects have been collect yet or not.
    
    Example::
    
        gw = GarbageWatcher()
        gw['objName'] = obj
        gw['objName2'] = obj2
        
        # Print status of all watched objects
        gw.check()  
        
        # Describe references leading to this object
        gw.describe('objName')
        
    """
    def __init__(self):
        self.objs = weakref.WeakValueDictionary()
        self.allNames = []
        
    def add(self, obj, name):
        self.objs[name] = obj
        self.allNames.append(name)
        
    def __setitem__(self, name, obj):
        self.add(obj, name)
        
    def check(self):
        """Print a list of all watched objects and whether they have been collected."""
        gc.collect()
        dead = self.allNames[:]
        alive = []
        for k in self.objs:
            dead.remove(k)
            alive.append(k)
        print("Deleted objects:", dead)
        print("Live objects:", alive)
        
    def __getitem__(self, item):
        return self.objs[item]

    def describe(self, key, **kwds):
        describeObj(self[key], **kwds)

    def __len__(self):
        return len(self.objs)
        